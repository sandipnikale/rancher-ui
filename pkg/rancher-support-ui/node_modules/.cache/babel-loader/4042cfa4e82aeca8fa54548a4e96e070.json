{"remainingRequest":"/app/node_modules/thread-loader/dist/cjs.js!/app/node_modules/babel-loader/lib/index.js!/app/node_modules/@rancher/shell/utils/create-yaml.js","dependencies":[{"path":"/app/node_modules/@rancher/shell/utils/create-yaml.js","mtime":1764054237091},{"path":"/app/pkg/rancher-support-ui/babel.config.js","mtime":1764051174054},{"path":"/app/node_modules/cache-loader/dist/cjs.js","mtime":1764054259024},{"path":"/app/node_modules/thread-loader/dist/cjs.js","mtime":1764054259111},{"path":"/app/node_modules/babel-loader/lib/index.js","mtime":1764054258910}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IHsgaW5kZW50IGFzIF9pbmRlbnQgfSBmcm9tICdAc2hlbGwvdXRpbHMvc3RyaW5nJzsKaW1wb3J0IHsgYWRkT2JqZWN0LCBmaW5kQnksIHJlbW92ZU9iamVjdCwgcmVtb3ZlT2JqZWN0cyB9IGZyb20gJ0BzaGVsbC91dGlscy9hcnJheSc7CmltcG9ydCBqc3lhbWwgZnJvbSAnanMteWFtbCc7CmltcG9ydCB7IGNsZWFuVXAsIGlzRW1wdHkgfSBmcm9tICdAc2hlbGwvdXRpbHMvb2JqZWN0JzsKaW1wb3J0IHsgcGFyc2VUeXBlIH0gZnJvbSAnQHNoZWxsL21vZGVscy9zY2hlbWEnOwpleHBvcnQgY29uc3QgU0lNUExFX1RZUEVTID0gWydzdHJpbmcnLCAnbXVsdGlsaW5lJywgJ21hc2tlZCcsICdwYXNzd29yZCcsICdmbG9hdCcsICdpbnQnLCAnZGF0ZScsICdibG9iJywgJ2Jvb2xlYW4nLCAndmVyc2lvbiddOwpjb25zdCBBTFdBWVNfQUREID0gWydhcGlWZXJzaW9uJywgJ2tpbmQnLCAnbWV0YWRhdGEnLCAnbWV0YWRhdGEubmFtZScsICdzcGVjJywgJ3NwZWMuc2VsZWN0b3InLCAnc3BlYy5zZWxlY3Rvci5tYXRjaExhYmVscycsICdzcGVjLnRlbXBsYXRlJywgJ3NwZWMudGVtcGxhdGUubWV0YWRhdGEnLCAnc3BlYy50ZW1wbGF0ZS5tZXRhZGF0YS5sYWJlbHMnLCAnc3BlYy50ZW1wbGF0ZS5zcGVjLmNvbnRhaW5lcnMubmFtZScsICdzcGVjLnRlbXBsYXRlLnNwZWMuY29udGFpbmVycy5pbWFnZSddOwpleHBvcnQgY29uc3QgTkVWRVJfQUREID0gWydtZXRhZGF0YS5jbHVzdGVyTmFtZScsICdtZXRhZGF0YS5jcmVhdGlvblRpbWVzdGFtcCcsICdtZXRhZGF0YS5kZWxldGlvbkdyYWNlUGVyaW9kU2Vjb25kcycsICdtZXRhZGF0YS5kZWxldGlvblRpbWVzdGFtcCcsICdtZXRhZGF0YS5maW5hbGl6ZXJzJywgJ21ldGFkYXRhLmdlbmVyYXRlTmFtZScsICdtZXRhZGF0YS5nZW5lcmF0aW9uJywgJ21ldGFkYXRhLmluaXRpYWxpemVycycsICdtZXRhZGF0YS5tYW5hZ2VkRmllbGRzJywgJ21ldGFkYXRhLm93bmVyUmVmZXJlbmNlcycsICdtZXRhZGF0YS5yZXNvdXJjZVZlcnNpb24nLCAnbWV0YWRhdGEucmVsYXRpb25zaGlwcycsICdtZXRhZGF0YS5zZWxmTGluaycsICdtZXRhZGF0YS5zdGF0ZScsICdtZXRhZGF0YS51aWQnLAovLyBDUkQgLT4gU2NoZW1hIGRlc2NyaWJlcyB0aGUgc2NoZW1hIHVzZWQgZm9yIHZhbGlkYXRpb24sIHBydW5pbmcsIGFuZCBkZWZhdWx0aW5nIG9mIHRoaXMgdmVyc2lvbiBvZiB0aGUgY3VzdG9tIHJlc291cmNlLiBJZiB3ZSBhbGxvdyBwcm9jZXNzaW5nIHdlIGZhbGwgaW50byBpbmYgbG9vcCBvbiBvcGVuQVBJVjNTY2hlbWEuYWxsT2Ygd2hpY2ggY29udGFpbnMgYSBjeWNsaWNhbCByZWYgb2YgYWxsT2YgcHJvcHMuCidzcGVjLnZlcnNpb25zLnNjaGVtYScsICdzdGF0dXMnLCAnc3RyaW5nRGF0YScsICdsaW5rcycsICdfbmFtZScsICdfbGFiZWxzJywgJ19hbm5vdGF0aW9ucyddOwpleHBvcnQgY29uc3QgQUNUSVZFTFlfUkVNT1ZFID0gWydtZXRhZGF0YS5tYW5hZ2VkRmllbGRzJywgJ21ldGFkYXRhLnJlbGF0aW9uc2hpcHMnLCAnbWV0YWRhdGEuc3RhdGUnLCAnc3RhdHVzJywgJ2xpbmtzJywgJ3R5cGUnLCAnaWQnXTsKY29uc3QgSU5ERU5UID0gMjsKZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVlhbWxXaXRoT3B0aW9ucyhzY2hlbWFzLCB0eXBlLCBkYXRhLCBvcHRpb25zKSB7CiAgcmV0dXJuIGNyZWF0ZVlhbWwoc2NoZW1hcywgdHlwZSwgZGF0YSwgdHJ1ZSwgMCwgJycsIG51bGwsIG9wdGlvbnMpOwp9CmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVZYW1sKHNjaGVtYXMsIHR5cGUsIGRhdGEsIHByb2Nlc3NBbHdheXNBZGQgPSB0cnVlLCBkZXB0aCA9IDAsIHBhdGggPSAnJywgcm9vdFR5cGUgPSBudWxsLCBkYXRhT3B0aW9ucyA9IHt9KSB7CiAgZGF0YSA9IGRhdGEgfHwge307CiAgbGV0IHNjaGVtYSwgcm9vdFNjaGVtYSwgc2NoZW1hRGVmaW5pdGlvbnMsIHNjaGVtYVJlc291cmNlRmllbGRzOwogIGlmIChkZXB0aCA9PT0gMCkgewogICAgLy8gYHR5cGVgIGlzIGEgc2NoZW1hIGlkCiAgICBzY2hlbWEgPSBmaW5kQnkoc2NoZW1hcywgJ2lkJywgdHlwZSk7CiAgICBpZiAoIXNjaGVtYSkgewogICAgICAvLyBzY2hlbWEgaXMgb25seSBuZWVkZWQgYXQgdGhlIHJvb3QgbGV2ZWwuCiAgICAgIHJldHVybiBgRXJyb3IgbG9hZGluZyBzY2hlbWEgZm9yICR7dHlwZX1gOwogICAgfQogICAgcm9vdFNjaGVtYSA9IHNjaGVtYTsKICAgIHNjaGVtYURlZmluaXRpb25zID0gcm9vdFNjaGVtYS5zY2hlbWFEZWZpbml0aW9uczsKICAgIHNjaGVtYVJlc291cmNlRmllbGRzID0gcm9vdFNjaGVtYS5yZXNvdXJjZUZpZWxkczsKICAgIGNvbnN0IGF0dHIgPSBzY2hlbWEuYXR0cmlidXRlcyB8fCB7fTsKCiAgICAvLyBEZWZhdWx0IHRvIGRhdGEuYXBpVmVyc2lvbi9raW5kIHRvIGFjY29tbW9kYXRlIHNwb29mZWQgdHlwZXMgdGhhdCBhZ2dyZWdhdGUgbXVsdGlwbGUgdHlwZXMKICAgIGRhdGEuYXBpVmVyc2lvbiA9IChhdHRyLmdyb3VwID8gYCR7YXR0ci5ncm91cH0vJHthdHRyLnZlcnNpb259YCA6IGF0dHIudmVyc2lvbikgfHwgZGF0YS5hcGlWZXJzaW9uOwogICAgZGF0YS5raW5kID0gYXR0ci5raW5kIHx8IGRhdGEua2luZDsKICB9IGVsc2UgewogICAgcm9vdFNjaGVtYSA9IGZpbmRCeShzY2hlbWFzLCAnaWQnLCByb290VHlwZSk7CiAgICBpZiAocm9vdFNjaGVtYS5yZXF1aXJlc1Jlc291cmNlRmllbGRzKSB7CiAgICAgIHZhciBfc2NoZW1hRGVmaW5pdGlvbnMkdHk7CiAgICAgIC8vIFNlZSBgcmVxdWlyZXNSZXNvdXJjZUZpZWxkc2AgZGVmaW5pdGlvbgogICAgICBzY2hlbWFEZWZpbml0aW9ucyA9IHJvb3RTY2hlbWEuc2NoZW1hRGVmaW5pdGlvbnM7CiAgICAgIHNjaGVtYVJlc291cmNlRmllbGRzID0gKF9zY2hlbWFEZWZpbml0aW9ucyR0eSA9IHNjaGVtYURlZmluaXRpb25zW3R5cGVdKSA9PT0gbnVsbCB8fCBfc2NoZW1hRGVmaW5pdGlvbnMkdHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zY2hlbWFEZWZpbml0aW9ucyR0eS5yZXNvdXJjZUZpZWxkczsKICAgIH0gZWxzZSB7CiAgICAgIHNjaGVtYSA9IGZpbmRCeShzY2hlbWFzLCAnaWQnLCB0eXBlKTsKICAgICAgaWYgKCFzY2hlbWEpIHsKICAgICAgICAvLyBzY2hlbWEgaXMgb25seSBuZWVkZWQgYXQgdGhlIHJvb3QgbGV2ZWwuCiAgICAgICAgcmV0dXJuIGBFcnJvciBsb2FkaW5nIHNjaGVtYSBmb3IgJHt0eXBlfWA7CiAgICAgIH0KICAgICAgc2NoZW1hUmVzb3VyY2VGaWVsZHMgPSBzY2hlbWEucmVzb3VyY2VGaWVsZHM7CiAgICB9CiAgfQogIGlmICghcm9vdFR5cGUpIHsKICAgIHJvb3RUeXBlID0gdHlwZTsKICB9CiAgY29uc3QgcmVndWxhckZpZWxkcyA9IFtdOwogIGlmIChwcm9jZXNzQWx3YXlzQWRkKSB7CiAgICAvLyBBZGQgYWxsIHRoZSBwYXJlbnRzIG9mIGVhY2gga2V5IHNvIHRoYXQgc3BlYy50ZW1wbGF0ZS5mb28uYmxhaAogICAgLy8gY2F1c2VzICdzcGVjJywgJ3RlbXBsYXRlJyBhbmQgJ2Zvbycga2V5cyB0byBiZSBjcmVhdGVkCiAgICBjb25zdCBhbHdheXMgPSBBTFdBWVNfQURELnNsaWNlKCk7CiAgICBmb3IgKGxldCBpID0gYWx3YXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7CiAgICAgIGxldCBlbnRyeSA9IGFsd2F5c1tpXS5zcGxpdCgvXC4vKTsKICAgICAgd2hpbGUgKGVudHJ5Lmxlbmd0aCkgewogICAgICAgIGFkZE9iamVjdChhbHdheXMsIGVudHJ5LmpvaW4oJy4nKSk7CiAgICAgICAgZW50cnkgPSBlbnRyeS5zbGljZSgwLCAtMSk7CiAgICAgIH0KICAgIH0KCiAgICAvLyBNYXJrIGFsd2F5cyBmaWVsZHMgYXMgcmVndWxhciBzbyB0aGV5J3JlIG5vdCBjb21tZW50ZWQgb3V0CiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGFsd2F5cykgewogICAgICBjb25zdCBwYXJ0cyA9IGVudHJ5LnNwbGl0KC9cLi8pOwogICAgICBjb25zdCBrZXkgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTsKICAgICAgY29uc3QgcHJlZml4ID0gcGFydHMuc2xpY2UoMCwgLTEpLmpvaW4oJy4nKTsKICAgICAgaWYgKHByZWZpeCA9PT0gcGF0aCAmJiBzY2hlbWFSZXNvdXJjZUZpZWxkcyAmJiBzY2hlbWFSZXNvdXJjZUZpZWxkc1trZXldKSB7CiAgICAgICAgYWRkT2JqZWN0KHJlZ3VsYXJGaWVsZHMsIGtleSk7CiAgICAgIH0KICAgIH0KICB9CgogIC8vIEluY2x1ZGUgYWxsIGZpZWxkcyBpbiBzY2hlbWEncyByZXNvdXJjZUZpZWxkcyBhcyBjb21tZW50cwogIGNvbnN0IGNvbW1lbnRGaWVsZHMgPSBPYmplY3Qua2V5cyhzY2hlbWFSZXNvdXJjZUZpZWxkcyB8fCB7fSk7CiAgY29tbWVudEZpZWxkcy5mb3JFYWNoKGtleSA9PiB7CiAgICBpZiAodHlwZW9mIGRhdGFba2V5XSAhPT0gJ3VuZGVmaW5lZCcgfHwgZGVwdGggPT09IDAgJiYga2V5ID09PSAnX3R5cGUnKSB7CiAgICAgIGFkZE9iamVjdChyZWd1bGFyRmllbGRzLCBrZXkpOwogICAgfQogIH0pOwoKICAvLyBhZGQgYW55IGZpZWxkcyBkZWZpbmVkIGluIGRhdGEgYXMgdW5jb21tZW50ZWQgZmllbGRzIGluIHlhbWwKICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7CiAgICBpZiAodHlwZW9mIGRhdGFba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgYWRkT2JqZWN0KHJlZ3VsYXJGaWVsZHMsIGtleSk7CiAgICB9CiAgfQoKICAvLyBBQ1RJVkVMWV9SRU1PVkUgYXJlIGZpZWxkcyB0aGF0IHNob3VsZCBiZSByZW1vdmVkIGV2ZW4gaWYgdGhleSBhcmUgZGVmaW5lZCBpbiBkYXRhCiAgZm9yIChjb25zdCBlbnRyeSBvZiBBQ1RJVkVMWV9SRU1PVkUpIHsKICAgIGNvbnN0IHBhcnRzID0gZW50cnkuc3BsaXQoL1wuLyk7CiAgICBjb25zdCBrZXkgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTsKICAgIGNvbnN0IHByZWZpeCA9IHBhcnRzLnNsaWNlKDAsIC0xKS5qb2luKCcuJyk7CiAgICBpZiAocHJlZml4ID09PSBwYXRoKSB7CiAgICAgIHJlbW92ZU9iamVjdChyZWd1bGFyRmllbGRzLCBrZXkpOwogICAgfQogIH0KCiAgLy8gTkVWRVJfQUREIGFyZSBmaWVsZHMgdGhhdCBzaG91bGQgbm90IGJlIGFkZGVkIGFzIGNvbW1lbnRzLCBidXQgbWF5IGFkZGVkIGFzIHJlZ3VsYXIgZmllbGRzIGlmIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhCiAgZm9yIChjb25zdCBlbnRyeSBvZiBORVZFUl9BREQpIHsKICAgIGNvbnN0IHBhcnRzID0gZW50cnkuc3BsaXQoL1wuLyk7CiAgICBjb25zdCBrZXkgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTsKICAgIGNvbnN0IHByZWZpeCA9IHBhcnRzLnNsaWNlKDAsIC0xKS5qb2luKCcuJyk7CiAgICBpZiAocHJlZml4ID09PSBwYXRoICYmIHNjaGVtYVJlc291cmNlRmllbGRzICYmIHNjaGVtYVJlc291cmNlRmllbGRzW2tleV0pIHsKICAgICAgcmVtb3ZlT2JqZWN0KGNvbW1lbnRGaWVsZHMsIGtleSk7CiAgICB9CiAgfQoKICAvLyBkbyBub3QgaW5jbHVkZSBjb21tZW50ZWQgZmllbGRzIGlmIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhCiAgcmVtb3ZlT2JqZWN0cyhjb21tZW50RmllbGRzLCByZWd1bGFyRmllbGRzKTsKICBjb25zdCByZWd1bGFyID0gcmVndWxhckZpZWxkcy5tYXAoayA9PiBzdHJpbmdpZnlGaWVsZChrKSk7CiAgY29uc3QgY29tbWVudHMgPSBjb21tZW50RmllbGRzLm1hcChrID0+IHsKICAgIC8vIERvbid0IGFkZCBhIG5hbWVzcGFjZSBjb21tZW50IGZvciB0eXBlcyB0aGF0IGFyZW4ndCBuYW1lc3BhY2VkLgogICAgaWYgKHBhdGggPT09ICdtZXRhZGF0YScgJiYgayA9PT0gJ25hbWVzcGFjZScpIHsKICAgICAgdmFyIF9yb290U2NoZW1hJGF0dHJpYnV0ZTsKICAgICAgaWYgKHJvb3RTY2hlbWEgJiYgISgoX3Jvb3RTY2hlbWEkYXR0cmlidXRlID0gcm9vdFNjaGVtYS5hdHRyaWJ1dGVzKSAhPT0gbnVsbCAmJiBfcm9vdFNjaGVtYSRhdHRyaWJ1dGUgIT09IHZvaWQgMCAmJiBfcm9vdFNjaGVtYSRhdHRyaWJ1dGUubmFtZXNwYWNlZCkpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQogICAgfQogICAgcmV0dXJuIGNvbW1lbnQoc3RyaW5naWZ5RmllbGQoaykpOwogIH0pOwogIGNvbnN0IG91dCA9IFsuLi5yZWd1bGFyLCAuLi5jb21tZW50c10uZmlsdGVyKHggPT4geCAhPT0gbnVsbCkuam9pbignXG4nKS50cmltKCk7CiAgcmV0dXJuIG91dDsKCiAgLy8gLS0tLS0tLS0tLS0tLS0tCgogIGZ1bmN0aW9uIHN0cmluZ2lmeUZpZWxkKGtleSkgewogICAgdmFyIF9zY2hlbWFSZXNvdXJjZUZpZWxkcywgX3NjaGVtYURlZmluaXRpb25zOwogICAgY29uc3QgZmllbGQgPSAoX3NjaGVtYVJlc291cmNlRmllbGRzID0gc2NoZW1hUmVzb3VyY2VGaWVsZHMpID09PSBudWxsIHx8IF9zY2hlbWFSZXNvdXJjZUZpZWxkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NjaGVtYVJlc291cmNlRmllbGRzW2tleV07CiAgICBsZXQgb3V0ID0gYCR7a2V5fTpgOwoKICAgIC8vICdfdHlwZScgaW4gc3RldmUgbWFwcyB0byBrdWJlcm5ldGVzICd0eXBlJyBmaWVsZDsgc2hvdyAndHlwZScgZmllbGQgaW4geWFtbAogICAgaWYgKGtleSA9PT0gJ190eXBlJykgewogICAgICBvdXQgPSAndHlwZTonOwogICAgfQoKICAgIC8vIGlmIGEga2V5IG9uIGRhdGEgaXMgbm90IGxpc3RlZCBpbiB0aGUgc2NoZW1hJ3MgcmVzb3VyY2VGaWVsZHMsIGp1c3QgY29udmVydCBpdCB0byB5YW1sLCBhZGQgaW5kZW50cyB3aGVyZSBuZWVkZWQsIGFuZCByZXR1cm4KICAgIGlmICghZmllbGQpIHsKICAgICAgaWYgKGRhdGFba2V5XSkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBjb25zdCBjbGVhbmVkID0gY2xlYW5VcChkYXRhKTsKICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBqc3lhbWwuZHVtcChjbGVhbmVkW2tleV0pOwogICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2tleV0gPT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSkgewogICAgICAgICAgICBvdXQgKz0gYFxuJHtpbmRlbnQocGFyc2VkRGF0YS50cmltKCkpfWA7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBvdXQgKz0gYCAke3BhcnNlZERhdGEudHJpbSgpfWA7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gb3V0OwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yOiBVbmFibGUgdG8gcGFyc2UgbWFwIGRhdGEgZm9yIHlhbWwga2V5OiAke2tleX1gLCBlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlCiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgY29uc3QgdHlwZSA9IHR5cGVNdW5nZShmaWVsZC50eXBlKTsKICAgIGNvbnN0IG1hcE9mID0gdHlwZVJlZignbWFwJywgdHlwZSwgZmllbGQpOwogICAgY29uc3QgYXJyYXlPZiA9IHR5cGVSZWYoJ2FycmF5JywgdHlwZSwgZmllbGQpOwogICAgY29uc3QgcmVmZXJlbmNlVG8gPSB0eXBlUmVmKCdyZWZlcmVuY2UnLCB0eXBlKTsKCiAgICAvLyB0eXBlID09IG1hcFttYXBPZl0KICAgIGlmIChtYXBPZikgewogICAgICAvLyBpZiBrZXkgaXMgZGVmaW5lZCBpbiBkYXRhLCBjb252ZXJ0IHRoZSB2YWx1ZSB0byB5YW1sLCBhZGQgbmV3bGluZStpbmRlbnQgYW5kIGFkZCB0byBvdXRwdXQgeWFtbCBzdHJpbmcKICAgICAgaWYgKGRhdGFba2V5XSkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBjb25zdCBjbGVhbmVkID0gY2xlYW5VcChkYXRhKTsKICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBkdW1wQmxvY2soY2xlYW5lZFtrZXldLCBkYXRhT3B0aW9uc1trZXldKTsKICAgICAgICAgIG91dCArPSBgXG4ke2luZGVudChwYXJzZWREYXRhKX1gOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yOiBVbmFibGUgdG8gcGFyc2UgbWFwIGRhdGEgZm9yIHlhbWwgb2YgdHlwZTogJHt0eXBlfWAsIGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGUKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKFNJTVBMRV9UWVBFUy5pbmNsdWRlcyhtYXBPZikpIHsKICAgICAgICBvdXQgKz0gYCMgIGtleTogJHttYXBPZn1gOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIElmIG5vdCBhIHNpbXBsZSB0eXBlIGllIHNvbWUgc29ydCBvZiBvYmplY3QvYXJyYXksIHJlY3Vyc2l2ZWx5IGJ1aWxkIG91dCBjb21tZW50ZWQgZmllbGRzIChub3RlIGRhdGEgPSBudWxsIGhlcmUpIHBlciB0aGUgdHlwZSdzIChtYXBPZidzKSBzY2hlbWEKICAgICAgICBjb25zdCBjaHVuayA9IGNyZWF0ZVlhbWwoc2NoZW1hcywgbWFwT2YsIG51bGwsIHByb2Nlc3NBbHdheXNBZGQsIGRlcHRoICsgMSwgcGF0aCA/IGAke3BhdGh9LiR7a2V5fWAgOiBrZXksIHJvb3RUeXBlLCBkYXRhT3B0aW9ucyk7CiAgICAgICAgbGV0IGluZGVudGVkID0gaW5kZW50KGNodW5rKTsKCiAgICAgICAgLy8gY29udmVydCAiIyAgICBmb28iIHRvICIjZm9vIgogICAgICAgIGluZGVudGVkID0gaW5kZW50ZWQucmVwbGFjZSgvXigjKT9cc1xzXHNccy8sICckMScpOwogICAgICAgIG91dCArPSBgJHtpbmRlbnRlZH1gOwogICAgICB9CiAgICAgIHJldHVybiBvdXQ7CiAgICB9CgogICAgLy8gdHlwZSA9PSBhcnJheVthcnJheU9mXQogICAgaWYgKGFycmF5T2YpIHsKICAgICAgaWYgKGRhdGFba2V5XSkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBjb25zdCBjbGVhbmVkID0gY2xlYW5VcChkYXRhKTsKICAgICAgICAgIGlmIChjbGVhbmVkICE9PSBudWxsICYmIGNsZWFuZWQgIT09IHZvaWQgMCAmJiBjbGVhbmVkW2tleV0pIHsKICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IGpzeWFtbC5kdW1wKGNsZWFuZWRba2V5XSk7CiAgICAgICAgICAgIG91dCArPSBgXG4ke2luZGVudChwYXJzZWREYXRhLnRyaW0oKSl9YDsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvcjogVW5hYmxlIHRvIHBhcnNlIGFycmF5IGRhdGEgZm9yIHlhbWwgb2YgdHlwZTogJHt0eXBlfWAsIGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGUKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKFNJTVBMRV9UWVBFUy5pbmNsdWRlcyhhcnJheU9mKSkgewogICAgICAgIG91dCArPSBgXG4jICAtICR7YXJyYXlPZn1gOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IGNodW5rID0gY3JlYXRlWWFtbChzY2hlbWFzLCBhcnJheU9mLCBudWxsLCBmYWxzZSwgZGVwdGggKyAxLCBwYXRoID8gYCR7cGF0aH0uJHtrZXl9YCA6IGtleSwgcm9vdFR5cGUsIGRhdGFPcHRpb25zKTsKICAgICAgICBsZXQgaW5kZW50ZWQgPSBpbmRlbnQoY2h1bmssIDIpOwoKICAgICAgICAvLyB0dXJuICIjICAgICAgICBmb28iIGludG8gIiMgIC0gZm9vIgogICAgICAgIGluZGVudGVkID0gaW5kZW50ZWQucmVwbGFjZSgvXigjKT9ccypcc1xzKFteXHNdKS8sICckMSAgLSAkMicpOwogICAgICAgIG91dCArPSBgXG4ke2luZGVudGVkfWA7CiAgICAgIH0KICAgICAgcmV0dXJuIG91dDsKICAgIH0KICAgIGlmIChyZWZlcmVuY2VUbykgewogICAgICBvdXQgKz0gYCAjJHtyZWZlcmVuY2VUb31gOwogICAgICByZXR1cm4gb3V0OwogICAgfQogICAgaWYgKFNJTVBMRV9UWVBFUy5pbmNsdWRlcyh0eXBlKSkgewogICAgICBpZiAoa2V5ID09PSAnX3R5cGUnICYmIHR5cGVvZiBkYXRhW2tleV0gPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkYXRhWyd0eXBlJ10gIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgb3V0ICs9IGAgJHtzZXJpYWxpemVTaW1wbGVWYWx1ZShkYXRhWyd0eXBlJ10pfWA7CiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGFba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICBvdXQgKz0gYCAjJHtzZXJpYWxpemVTaW1wbGVWYWx1ZSh0eXBlKX1gOwogICAgICB9IGVsc2UgewogICAgICAgIG91dCArPSBgICR7c2VyaWFsaXplU2ltcGxlVmFsdWUoZGF0YVtrZXldKX1gOwogICAgICB9CiAgICAgIHJldHVybiBvdXQ7CiAgICB9CgogICAgLyoqCiAgICAgKiAuc3BlYyBpcyB0aGUgdHlwZSB1c2VkIGZvciB0aGUgTG9nZ2luZyBjaGFydCBPdXRwdXQgYW5kIENsdXN0ZXJPdXRwdXQgcmVzb3VyY2Ugc3BlYy4KICAgICAqIFdpdGhvdXQgdGhpcyBPdXRwdXQgYW5kIENsdXN0ZXJPdXRwdXQgc3BlY3MgYXJlIGVtcHR5LgogICAgICovCiAgICBpZiAodHlwZSA9PT0gJ2pzb24nIHx8IHR5cGUgPT09ICcuc3BlYycpIHsKICAgICAgdHJ5IHsKICAgICAgICBjb25zdCBwYXJzZWREYXRhID0ganN5YW1sLmR1bXAoZGF0YVtrZXldKTsKICAgICAgICBpZiAocGFyc2VkRGF0YSkgewogICAgICAgICAgb3V0ICs9IGBcbiR7aW5kZW50KHBhcnNlZERhdGEudHJpbSgpKX1gOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBvdXQgKz0gYCAjJHt0eXBlfWA7CiAgICAgICAgfQogICAgICAgIHJldHVybiBvdXQ7CiAgICAgIH0gY2F0Y2ggKGUpIHt9CiAgICB9CiAgICBjb25zdCBzdWJEZWYgPSAoKF9zY2hlbWFEZWZpbml0aW9ucyA9IHNjaGVtYURlZmluaXRpb25zKSA9PT0gbnVsbCB8fCBfc2NoZW1hRGVmaW5pdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zY2hlbWFEZWZpbml0aW9uc1t0eXBlXSkgfHwgZmluZEJ5KHNjaGVtYXMsICdpZCcsIHR5cGUpOwogICAgaWYgKHN1YkRlZikgewogICAgICBsZXQgY2h1bms7CiAgICAgIGlmIChzdWJEZWYgIT09IG51bGwgJiYgc3ViRGVmICE9PSB2b2lkIDAgJiYgc3ViRGVmLnJlc291cmNlRmllbGRzICYmICFpc0VtcHR5KHN1YkRlZiA9PT0gbnVsbCB8fCBzdWJEZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1YkRlZi5yZXNvdXJjZUZpZWxkcykpIHsKICAgICAgICBjaHVuayA9IGNyZWF0ZVlhbWwoc2NoZW1hcywgdHlwZSwgZGF0YVtrZXldLCBwcm9jZXNzQWx3YXlzQWRkLCBkZXB0aCArIDEsIHBhdGggPyBgJHtwYXRofS4ke2tleX1gIDoga2V5LCByb290VHlwZSwgZGF0YU9wdGlvbnMpOwogICAgICB9IGVsc2UgaWYgKGRhdGFba2V5XSkgewogICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBmaWVsZHMgZGVmaW5lZCBvbiB0aGUgc2NoZW1hIGJ1dCB0aGVyZSBhcmUgaW4gdGhlIGRhdGEsIGp1c3QgZm9ybWF0IGRhdGEgYXMgeWFtbCBhbmQgYWRkIHRvIG91dHB1dCB5YW1sCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IGpzeWFtbC5kdW1wKGRhdGFba2V5XSk7CiAgICAgICAgICBjaHVuayA9IHBhcnNlZC50cmltKCk7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3I6IFVuYWxlIHRvIHBhcnNlIGRhdGEgZm9yIHlhbWwgb2YgdHlwZTogJHt0eXBlfWAsIGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGUKICAgICAgICB9CiAgICAgIH0KICAgICAgb3V0ICs9IGBcbiR7aW5kZW50KGNodW5rKX1gOwogICAgfSBlbHNlIHsKICAgICAgb3V0ICs9IGAgIyR7dHlwZX1gOwogICAgfQogICAgcmV0dXJuIG91dDsKICB9Cn0KZnVuY3Rpb24gY29tbWVudChsaW5lcykgewogIHJldHVybiAobGluZXMgfHwgJycpLnNwbGl0KCdcbicpLm1hcCh4ID0+IGAjJHt4LnJlcGxhY2UoLyMvZywgJycpfWApLmpvaW4oJ1xuJyk7Cn0KZnVuY3Rpb24gaW5kZW50KGxpbmVzLCBkZXB0aCA9IDEpIHsKICByZXR1cm4gX2luZGVudChsaW5lcywgZGVwdGggKiBJTkRFTlQsICcgJywgL14jLyk7Cn0KZnVuY3Rpb24gc2VyaWFsaXplU2ltcGxlVmFsdWUoZGF0YSkgewogIHJldHVybiBqc3lhbWwuZHVtcChkYXRhKS50cmltKCk7Cn0KZXhwb3J0IGZ1bmN0aW9uIGdldEJsb2NrRGVzY3JpcHRvcih2YWx1ZSwga2V5KSB7CiAgY29uc3QgaGVhZGVyID0gZ2V0QmxvY2tIZWFkZXIodmFsdWUsIGtleSk7CiAgcmV0dXJuIHsKICAgIGhlYWRlciwKICAgIGluZGVudGF0aW9uOiBnZXRCbG9ja0luZGVudGF0aW9uKGhlYWRlcikKICB9Owp9CgovKioKICoKICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRoZSBibG9jayBvZiB0ZXh0IHRvIGJlIHBhcnNlZAogKiBAcGFyYW0geyp9IGJsb2NrS2V5IHRoZSBrZXkgb2YgdGhlIGJsb2NrCiAqIEByZXR1cm5zIHRoZSBrZXkgKyB0aGUgYmxvY2sgc2NhbGFyIGluZGljYXRvcnMsIHNlZSBodHRwczovL3lhbWwtbXVsdGlsaW5lLmluZm8gLSBCbG9jayBTY2FsYXJzCiAqLwpmdW5jdGlvbiBnZXRCbG9ja0hlYWRlcih2YWx1ZSwgYmxvY2tLZXkpIHsKICBjb25zdCBjYXJkID0gYCgke2Jsb2NrS2V5fSlbXFw6XVtcXHN8XFx0XStbXFx8XFw+XVtcXGRdKltcXC1cXCtdP2A7CiAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKGNhcmQsICdnaScpOwogIGNvbnN0IGZvdW5kID0gdmFsdWUubWF0Y2gocmUpOwogIHJldHVybiAoZm91bmQgPT09IG51bGwgfHwgZm91bmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvdW5kWzBdKSB8fCAnJzsKfQoKLyoqCiAqCiAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja0hlYWRlciB0aGUga2V5ICsgdGhlIGJsb2NrIHNjYWxhciBpbmRpY2F0b3JzCiAqIEByZXR1cm5zIHRoZSBpbmRlbnRhdGlvbiBpbmRpY2F0b3IgZnJvbSB0aGUgYmxvY2sgaGVhZGVyLCBzZWUgaHR0cHM6Ly95YW1sLW11bHRpbGluZS5pbmZvIC0gSW5kZW50YXRpb24KICovCmZ1bmN0aW9uIGdldEJsb2NrSW5kZW50YXRpb24oYmxvY2tIZWFkZXIpIHsKICBjb25zdCBibG9ja1NjYWxhcnMgPSBibG9ja0hlYWRlci5zdWJzdHIoYmxvY2tIZWFkZXIuaW5kZXhPZignOicpICsgMSk7CiAgY29uc3QgaW5kZW50YXRpb24gPSBibG9ja1NjYWxhcnMubWF0Y2goL1xkKy8pOwogIHJldHVybiAoaW5kZW50YXRpb24gPT09IG51bGwgfHwgaW5kZW50YXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZGVudGF0aW9uWzBdKSB8fCAnJzsKfQoKLyoqCiAqIENoZWNrIGZvciBhIHNwZWNpZmljIHR5cGUgYW5kIGlmIHZhbGlkIHJldHVybiBpdCdzIHN1YiB0eXBlIG9yIHNlbGYKICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgcmVxdWlyZWQgdHlwZQogKiBAcGFyYW0ge3N0cmluZ30gc3RyIGFjdHVhbCB0eXBlCiAqIEBwYXJhbSB7UmVzb3VyY2VGaWVsZH0gZmllbGQgcmVzb3VyY2VGaWVsZCBlbnRyeSB0byB0aGUgYWN0dWFsIHR5cGUKICoKICogQHJldHVybnMgdGhlIHN1YiB0eXBlLCBvciBpZiBub3QgZm91bmQgdGhlIHR5cGUKICovCmV4cG9ydCBmdW5jdGlvbiB0eXBlUmVmKHR5cGUsIHN0ciwgZmllbGQgPSBudWxsKSB7CiAgY29uc3QgW2ZvdW5kVHlwZSwgZm91bmRTdWJUeXBlXSA9IHBhcnNlVHlwZShzdHIsIGZpZWxkKTsKICBpZiAodHlwZSA9PT0gZm91bmRUeXBlKSB7CiAgICByZXR1cm4gdHlwZU11bmdlKGZvdW5kU3ViVHlwZSB8fCBmb3VuZFR5cGUpOwogIH0KfQpleHBvcnQgZnVuY3Rpb24gdHlwZU11bmdlKHR5cGUpIHsKICBpZiAodHlwZSA9PT0gJ2ludGVnZXInKSB7CiAgICByZXR1cm4gJ2ludCc7CiAgfQogIGlmICh0eXBlID09PSAnaW8uazhzLmFwaW1hY2hpbmVyeS5wa2cuYXBpLnJlc291cmNlLlF1YW50aXR5JykgewogICAgcmV0dXJuICdzdHJpbmcnOwogIH0KICByZXR1cm4gdHlwZTsKfQpleHBvcnQgZnVuY3Rpb24gc2FmZXJEdW1wKG9iaikgewogIGNvbnN0IG91dCA9IGpzeWFtbC5kdW1wKG9iaiB8fCB7fSk7CiAgaWYgKG91dCA9PT0gJ3t9XG4nKSB7CiAgICByZXR1cm4gJyc7CiAgfQogIHJldHVybiBvdXQ7Cn0KCi8qKgogKiBIYW5kbGVzIG5ld2xpbmVzIGluZGljYXRvcnMgaW4gdGhlIG11bHRpbGluZSBibG9ja3MuCiAqCiAqIHRoaXMgaXMgcmVxdWlyZWQgc2luY2UganN5YW1sLmR1bXAgZG9lc24ndCBzdXBwb3J0IGNob21waW5nIGFuZCBzY2FsYXIgc3R5bGUgYXQgdGhlIG1vbWVudC4KICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL2pzLXlhbWwvaXNzdWVzLzE3MQoKICogQHR5cGVkZWYge09iamVjdH0gRHVtcEJsb2NrT3B0aW9ucwogKiBAcHJvcGVydHkgeygnPicgfCAnfCcpfSBbc2NhbGFyU3R5bGVdIC0gVGhlIHNjYWxhciBzdHlsZS4KICogQHByb3BlcnR5IHsoJy0nIHwgJysnIHwgJycgfCBudWxsKX0gW2Nob21waW5nXSAtIFRoZSBjaG9tcGluZyBzdHlsZS4KICoKICogQHBhcmFtIHsqfSBkYXRhIHRoZSBtdWx0aWxpbmUgYmxvY2sKICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBTZXJpYWxpemF0aW9uIG9wdGlvbnMgZm9yIGpzeWFtbC5kdW1wLgogKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5saW5lV2lkdGggLSBTZXQgbWF4IGxpbmUgd2lkdGguIFNldCAtMSBmb3IgdW5saW1pdGVkIHdpZHRoLgogKiBAcGFyYW0ge0R1bXBCbG9ja09wdGlvbnN9IFtvcHRpb25zLmR5bmFtaWNQcm9wZXJ0aWVzXSAtIE9wdGlvbnMgZm9yIGR5bmFtaWMgcHJvcGVydGllcy4KICogICBEZXZlbG9wZXJzIGNhbiBwcm92aWRlIHRoZWlyIG93biBwcm9wZXJ0eSBuYW1lcyB1bmRlciBgb3B0aW9uc2AuCiAqCiAqIEByZXR1cm5zIHRoZSByZXN1bHQgb2YganN5YW1sLmR1bXAgd2l0aCB0aGUgYWRkaXRpb24gb2YgbXVsdGlsaW5lIGluZGljYXRvcnMKICovCmV4cG9ydCBmdW5jdGlvbiBkdW1wQmxvY2soZGF0YSwgb3B0aW9ucyA9IHsKICBsaW5lV2lkdGg6IC0xCn0pIHsKICBjb25zdCBwYXJzZWQgPSBqc3lhbWwuZHVtcChkYXRhLCBvcHRpb25zKTsKICBsZXQgb3V0ID0gcGFyc2VkOwogIGNvbnN0IGJsb2NrRmllbGRzID0gT2JqZWN0LmtleXMoZGF0YSkuZmlsdGVyKGsgPT4gewogICAgaWYgKHR5cGVvZiBkYXRhW2tdID09PSAnc3RyaW5nJykgewogICAgICByZXR1cm4gZGF0YVtrXS5pbmNsdWRlcygnXG4nKTsKICAgIH0KICB9KTsKICBpZiAoYmxvY2tGaWVsZHMubGVuZ3RoKSB7CiAgICBmb3IgKGNvbnN0IGtleSBvZiBibG9ja0ZpZWxkcykgewogICAgICB2YXIgX29wdGlvbnMka2V5JHNjYWxhclN0LCBfb3B0aW9ucyRrZXksIF9vcHRpb25zJGtleSRjaG9tcGluZywgX29wdGlvbnMka2V5MjsKICAgICAgY29uc3QgewogICAgICAgIGhlYWRlciwKICAgICAgICBpbmRlbnRhdGlvbgogICAgICB9ID0gZ2V0QmxvY2tEZXNjcmlwdG9yKG91dCwga2V5KTsKICAgICAgY29uc3Qgc2NhbGFyU3R5bGUgPSAoX29wdGlvbnMka2V5JHNjYWxhclN0ID0gKF9vcHRpb25zJGtleSA9IG9wdGlvbnNba2V5XSkgPT09IG51bGwgfHwgX29wdGlvbnMka2V5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRrZXkuc2NhbGFyU3R5bGUpICE9PSBudWxsICYmIF9vcHRpb25zJGtleSRzY2FsYXJTdCAhPT0gdm9pZCAwID8gX29wdGlvbnMka2V5JHNjYWxhclN0IDogJ3wnOwogICAgICBjb25zdCBjaG9tcGluZyA9IChfb3B0aW9ucyRrZXkkY2hvbXBpbmcgPSAoX29wdGlvbnMka2V5MiA9IG9wdGlvbnNba2V5XSkgPT09IG51bGwgfHwgX29wdGlvbnMka2V5MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMka2V5Mi5jaG9tcGluZykgIT09IG51bGwgJiYgX29wdGlvbnMka2V5JGNob21waW5nICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRrZXkkY2hvbXBpbmcgOiAnJzsKCiAgICAgIC8qKgogICAgICAgKiBSZXBsYWNlIHRoZSBvcmlnaW5hbCBibG9jayBpbmRpY2F0b3JzIHdpdGggdGhlIG9uZXMgcHJvdmlkZWQgaW4gdGhlIG9wdGlvbnMgcGFyYW0KICAgICAgICovCiAgICAgIGlmIChoZWFkZXIpIHsKICAgICAgICBvdXQgPSBvdXQucmVwbGFjZShoZWFkZXIsIGAke2tleX06ICR7c2NhbGFyU3R5bGV9JHtjaG9tcGluZ30ke2luZGVudGF0aW9ufWApOwogICAgICB9CiAgICB9CiAgfQogIHJldHVybiBvdXQ7Cn0="},{"version":3,"names":["indent","_indent","addObject","findBy","removeObject","removeObjects","jsyaml","cleanUp","isEmpty","parseType","SIMPLE_TYPES","ALWAYS_ADD","NEVER_ADD","ACTIVELY_REMOVE","INDENT","createYamlWithOptions","schemas","type","data","options","createYaml","processAlwaysAdd","depth","path","rootType","dataOptions","schema","rootSchema","schemaDefinitions","schemaResourceFields","resourceFields","attr","attributes","apiVersion","group","version","kind","requiresResourceFields","_schemaDefinitions$ty","regularFields","always","slice","i","length","entry","split","join","parts","key","prefix","commentFields","Object","keys","forEach","regular","map","k","stringifyField","comments","_rootSchema$attribute","namespaced","comment","out","filter","x","trim","_schemaResourceFields","_schemaDefinitions","field","cleaned","parsedData","dump","Array","isArray","e","console","error","typeMunge","mapOf","typeRef","arrayOf","referenceTo","dumpBlock","includes","chunk","indented","replace","serializeSimpleValue","subDef","parsed","lines","getBlockDescriptor","value","header","getBlockHeader","indentation","getBlockIndentation","blockKey","card","re","RegExp","found","match","blockHeader","blockScalars","substr","indexOf","str","foundType","foundSubType","saferDump","obj","lineWidth","blockFields","_options$key$scalarSt","_options$key","_options$key$chomping","_options$key2","scalarStyle","chomping"],"sources":["/app/node_modules/@rancher/shell/utils/create-yaml.js"],"sourcesContent":["import { indent as _indent } from '@shell/utils/string';\nimport { addObject, findBy, removeObject, removeObjects } from '@shell/utils/array';\nimport jsyaml from 'js-yaml';\nimport { cleanUp, isEmpty } from '@shell/utils/object';\nimport { parseType } from '@shell/models/schema';\n\nexport const SIMPLE_TYPES = [\n  'string',\n  'multiline',\n  'masked',\n  'password',\n  'float',\n  'int',\n  'date',\n  'blob',\n  'boolean',\n  'version'\n];\n\nconst ALWAYS_ADD = [\n  'apiVersion',\n  'kind',\n  'metadata',\n  'metadata.name',\n  'spec',\n  'spec.selector',\n  'spec.selector.matchLabels',\n  'spec.template',\n  'spec.template.metadata',\n  'spec.template.metadata.labels',\n  'spec.template.spec.containers.name',\n  'spec.template.spec.containers.image',\n];\n\nexport const NEVER_ADD = [\n  'metadata.clusterName',\n  'metadata.creationTimestamp',\n  'metadata.deletionGracePeriodSeconds',\n  'metadata.deletionTimestamp',\n  'metadata.finalizers',\n  'metadata.generateName',\n  'metadata.generation',\n  'metadata.initializers',\n  'metadata.managedFields',\n  'metadata.ownerReferences',\n  'metadata.resourceVersion',\n  'metadata.relationships',\n  'metadata.selfLink',\n  'metadata.state',\n  'metadata.uid',\n  // CRD -> Schema describes the schema used for validation, pruning, and defaulting of this version of the custom resource. If we allow processing we fall into inf loop on openAPIV3Schema.allOf which contains a cyclical ref of allOf props.\n  'spec.versions.schema',\n  'status',\n  'stringData',\n  'links',\n  '_name',\n  '_labels',\n  '_annotations',\n];\n\nexport const ACTIVELY_REMOVE = [\n  'metadata.managedFields',\n  'metadata.relationships',\n  'metadata.state',\n  'status',\n  'links',\n  'type',\n  'id'\n];\n\nconst INDENT = 2;\n\nexport function createYamlWithOptions(schemas, type, data, options) {\n  return createYaml(\n    schemas,\n    type,\n    data,\n    true, 0, '', null,\n    options\n  );\n}\n\nexport function createYaml(\n  schemas,\n  type,\n  data,\n  processAlwaysAdd = true,\n  depth = 0,\n  path = '',\n  rootType = null,\n  dataOptions = {},\n) {\n  data = data || {};\n\n  let schema, rootSchema, schemaDefinitions, schemaResourceFields;\n\n  if (depth === 0) {\n    // `type` is a schema id\n    schema = findBy(schemas, 'id', type);\n\n    if ( !schema ) { // schema is only needed at the root level.\n      return `Error loading schema for ${ type }`;\n    }\n\n    rootSchema = schema;\n\n    schemaDefinitions = rootSchema.schemaDefinitions;\n    schemaResourceFields = rootSchema.resourceFields;\n\n    const attr = schema.attributes || {};\n\n    // Default to data.apiVersion/kind to accommodate spoofed types that aggregate multiple types\n    data.apiVersion = (attr.group ? `${ attr.group }/${ attr.version }` : attr.version) || data.apiVersion;\n    data.kind = attr.kind || data.kind;\n  } else {\n    rootSchema = findBy(schemas, 'id', rootType);\n\n    if (rootSchema.requiresResourceFields) { // See `requiresResourceFields` definition\n      schemaDefinitions = rootSchema.schemaDefinitions;\n      schemaResourceFields = schemaDefinitions[type]?.resourceFields;\n    } else {\n      schema = findBy(schemas, 'id', type);\n      if ( !schema ) { // schema is only needed at the root level.\n        return `Error loading schema for ${ type }`;\n      }\n      schemaResourceFields = schema.resourceFields;\n    }\n  }\n\n  if ( !rootType ) {\n    rootType = type;\n  }\n\n  const regularFields = [];\n\n  if (processAlwaysAdd) {\n    // Add all the parents of each key so that spec.template.foo.blah\n    // causes 'spec', 'template' and 'foo' keys to be created\n    const always = ALWAYS_ADD.slice();\n\n    for ( let i = always.length - 1 ; i >= 0 ; i-- ) {\n      let entry = always[i].split(/\\./);\n\n      while ( entry.length ) {\n        addObject(always, entry.join('.'));\n        entry = entry.slice(0, -1);\n      }\n    }\n\n    // Mark always fields as regular so they're not commented out\n    for ( const entry of always ) {\n      const parts = entry.split(/\\./);\n      const key = parts[parts.length - 1];\n      const prefix = parts.slice(0, -1).join('.');\n\n      if ( prefix === path && schemaResourceFields && schemaResourceFields[key] ) {\n        addObject(regularFields, key);\n      }\n    }\n  }\n\n  // Include all fields in schema's resourceFields as comments\n  const commentFields = Object.keys(schemaResourceFields || {});\n\n  commentFields.forEach((key) => {\n    if ( typeof data[key] !== 'undefined' || (depth === 0 && key === '_type') ) {\n      addObject(regularFields, key);\n    }\n  });\n\n  // add any fields defined in data as uncommented fields in yaml\n  for ( const key in data ) {\n    if ( typeof data[key] !== 'undefined' ) {\n      addObject(regularFields, key);\n    }\n  }\n\n  // ACTIVELY_REMOVE are fields that should be removed even if they are defined in data\n  for ( const entry of ACTIVELY_REMOVE ) {\n    const parts = entry.split(/\\./);\n    const key = parts[parts.length - 1];\n    const prefix = parts.slice(0, -1).join('.');\n\n    if ( prefix === path) {\n      removeObject(regularFields, key);\n    }\n  }\n\n  // NEVER_ADD are fields that should not be added as comments, but may added as regular fields if already defined in data\n  for ( const entry of NEVER_ADD ) {\n    const parts = entry.split(/\\./);\n    const key = parts[parts.length - 1];\n    const prefix = parts.slice(0, -1).join('.');\n\n    if ( prefix === path && schemaResourceFields && schemaResourceFields[key] ) {\n      removeObject(commentFields, key);\n    }\n  }\n\n  // do not include commented fields if already defined in data\n  removeObjects(commentFields, regularFields);\n\n  const regular = regularFields.map((k) => stringifyField(k));\n  const comments = commentFields.map((k) => {\n    // Don't add a namespace comment for types that aren't namespaced.\n    if ( path === 'metadata' && k === 'namespace' ) {\n      if ( rootSchema && !rootSchema.attributes?.namespaced ) {\n        return null;\n      }\n    }\n\n    return comment(stringifyField(k));\n  });\n\n  const out = [...regular, ...comments]\n    .filter((x) => x !== null)\n    .join('\\n')\n    .trim();\n\n  return out;\n\n  // ---------------\n\n  function stringifyField(key) {\n    const field = schemaResourceFields?.[key];\n    let out = `${ key }:`;\n\n    // '_type' in steve maps to kubernetes 'type' field; show 'type' field in yaml\n    if (key === '_type') {\n      out = 'type:';\n    }\n\n    // if a key on data is not listed in the schema's resourceFields, just convert it to yaml, add indents where needed, and return\n    if ( !field ) {\n      if (data[key]) {\n        try {\n          const cleaned = cleanUp(data);\n          const parsedData = jsyaml.dump(cleaned[key]);\n\n          if ( typeof data[key] === 'object' || Array.isArray(data[key]) ) {\n            out += `\\n${ indent(parsedData.trim()) }`;\n          } else {\n            out += ` ${ parsedData.trim() }`;\n          }\n\n          return out;\n        } catch (e) {\n          console.error(`Error: Unable to parse map data for yaml key: ${ key }`, e); // eslint-disable-line no-console\n        }\n      }\n\n      return null;\n    }\n\n    const type = typeMunge(field.type);\n    const mapOf = typeRef('map', type, field);\n    const arrayOf = typeRef('array', type, field);\n    const referenceTo = typeRef('reference', type);\n\n    // type == map[mapOf]\n    if ( mapOf ) {\n      // if key is defined in data, convert the value to yaml, add newline+indent and add to output yaml string\n      if (data[key]) {\n        try {\n          const cleaned = cleanUp(data);\n          const parsedData = dumpBlock(cleaned[key], dataOptions[key]);\n\n          out += `\\n${ indent(parsedData) }`;\n        } catch (e) {\n          console.error(`Error: Unable to parse map data for yaml of type: ${ type }`, e); // eslint-disable-line no-console\n        }\n      }\n\n      if ( SIMPLE_TYPES.includes(mapOf) ) {\n        out += `#  key: ${ mapOf }`;\n      } else {\n        // If not a simple type ie some sort of object/array, recursively build out commented fields (note data = null here) per the type's (mapOf's) schema\n        const chunk = createYaml(schemas, mapOf, null, processAlwaysAdd, depth + 1, (path ? `${ path }.${ key }` : key), rootType, dataOptions);\n        let indented = indent(chunk);\n\n        // convert \"#    foo\" to \"#foo\"\n        indented = indented.replace(/^(#)?\\s\\s\\s\\s/, '$1');\n\n        out += `${ indented }`;\n      }\n\n      return out;\n    }\n\n    // type == array[arrayOf]\n    if ( arrayOf ) {\n      if (data[key]) {\n        try {\n          const cleaned = cleanUp(data);\n\n          if ( cleaned?.[key] ) {\n            const parsedData = jsyaml.dump(cleaned[key]);\n\n            out += `\\n${ indent(parsedData.trim()) }`;\n          }\n        } catch (e) {\n          console.error(`Error: Unable to parse array data for yaml of type: ${ type }`, e); // eslint-disable-line no-console\n        }\n      }\n\n      if ( SIMPLE_TYPES.includes(arrayOf) ) {\n        out += `\\n#  - ${ arrayOf }`;\n      } else {\n        const chunk = createYaml(schemas, arrayOf, null, false, depth + 1, (path ? `${ path }.${ key }` : key), rootType, dataOptions);\n        let indented = indent(chunk, 2);\n\n        // turn \"#        foo\" into \"#  - foo\"\n        indented = indented.replace(/^(#)?\\s*\\s\\s([^\\s])/, '$1  - $2');\n\n        out += `\\n${ indented }`;\n      }\n\n      return out;\n    }\n\n    if ( referenceTo ) {\n      out += ` #${ referenceTo }`;\n\n      return out;\n    }\n\n    if ( SIMPLE_TYPES.includes(type) ) {\n      if (key === '_type' && typeof data[key] === 'undefined' && typeof data['type'] !== 'undefined') {\n        out += ` ${ serializeSimpleValue(data['type']) }`;\n      } else if ( typeof data[key] === 'undefined' ) {\n        out += ` #${ serializeSimpleValue(type) }`;\n      } else {\n        out += ` ${ serializeSimpleValue(data[key]) }`;\n      }\n\n      return out;\n    }\n\n    /**\n     * .spec is the type used for the Logging chart Output and ClusterOutput resource spec.\n     * Without this Output and ClusterOutput specs are empty.\n     */\n    if ( type === 'json' || type === '.spec') {\n      try {\n        const parsedData = jsyaml.dump(data[key]);\n\n        if (parsedData) {\n          out += `\\n${ indent(parsedData.trim()) }`;\n        } else {\n          out += ` #${ type }`;\n        }\n\n        return out;\n      } catch (e) {\n      }\n    }\n\n    const subDef = schemaDefinitions?.[type] || findBy(schemas, 'id', type);\n\n    if ( subDef) {\n      let chunk;\n\n      if (subDef?.resourceFields && !isEmpty(subDef?.resourceFields)) {\n        chunk = createYaml(schemas, type, data[key], processAlwaysAdd, depth + 1, (path ? `${ path }.${ key }` : key), rootType, dataOptions);\n      } else if (data[key]) {\n        // if there are no fields defined on the schema but there are in the data, just format data as yaml and add to output yaml\n        try {\n          const parsed = jsyaml.dump(data[key]);\n\n          chunk = parsed.trim();\n        } catch (e) {\n          console.error(`Error: Unale to parse data for yaml of type: ${ type }`, e); // eslint-disable-line no-console\n        }\n      }\n\n      out += `\\n${ indent(chunk) }`;\n    } else {\n      out += ` #${ type }`;\n    }\n\n    return out;\n  }\n}\n\nfunction comment(lines) {\n  return (lines || '').split('\\n').map((x) => `#${ x.replace(/#/g, '') }`).join('\\n');\n}\n\nfunction indent(lines, depth = 1) {\n  return _indent(lines, depth * INDENT, ' ', /^#/);\n}\n\nfunction serializeSimpleValue(data) {\n  return jsyaml.dump(data).trim();\n}\n\nexport function getBlockDescriptor(value, key) {\n  const header = getBlockHeader(value, key);\n\n  return {\n    header,\n    indentation: getBlockIndentation(header),\n  };\n}\n\n/**\n *\n * @param {string} value the block of text to be parsed\n * @param {*} blockKey the key of the block\n * @returns the key + the block scalar indicators, see https://yaml-multiline.info - Block Scalars\n */\nfunction getBlockHeader(value, blockKey) {\n  const card = `(${ blockKey })[\\\\:][\\\\s|\\\\t]+[\\\\|\\\\>][\\\\d]*[\\\\-\\\\+]?`;\n  const re = new RegExp(card, 'gi');\n\n  const found = value.match(re);\n\n  return found?.[0] || '';\n}\n\n/**\n *\n * @param {string} blockHeader the key + the block scalar indicators\n * @returns the indentation indicator from the block header, see https://yaml-multiline.info - Indentation\n */\nfunction getBlockIndentation(blockHeader) {\n  const blockScalars = blockHeader.substr(blockHeader.indexOf(':') + 1);\n\n  const indentation = blockScalars.match(/\\d+/);\n\n  return indentation?.[0] || '';\n}\n\n/**\n * Check for a specific type and if valid return it's sub type or self\n * @param {string} type required type\n * @param {string} str actual type\n * @param {ResourceField} field resourceField entry to the actual type\n *\n * @returns the sub type, or if not found the type\n */\nexport function typeRef(type, str, field = null) {\n  const [foundType, foundSubType] = parseType(str, field);\n\n  if (type === foundType) {\n    return typeMunge(foundSubType || foundType);\n  }\n}\n\nexport function typeMunge(type) {\n  if ( type === 'integer' ) {\n    return 'int';\n  }\n\n  if ( type === 'io.k8s.apimachinery.pkg.api.resource.Quantity' ) {\n    return 'string';\n  }\n\n  return type;\n}\n\nexport function saferDump(obj) {\n  const out = jsyaml.dump(obj || {});\n\n  if ( out === '{}\\n' ) {\n    return '';\n  }\n\n  return out;\n}\n\n/**\n * Handles newlines indicators in the multiline blocks.\n *\n * this is required since jsyaml.dump doesn't support chomping and scalar style at the moment.\n * see: https://github.com/nodeca/js-yaml/issues/171\n\n * @typedef {Object} DumpBlockOptions\n * @property {('>' | '|')} [scalarStyle] - The scalar style.\n * @property {('-' | '+' | '' | null)} [chomping] - The chomping style.\n *\n * @param {*} data the multiline block\n * @param {Object} options - Serialization options for jsyaml.dump.\n * @param {number} options.lineWidth - Set max line width. Set -1 for unlimited width.\n * @param {DumpBlockOptions} [options.dynamicProperties] - Options for dynamic properties.\n *   Developers can provide their own property names under `options`.\n *\n * @returns the result of jsyaml.dump with the addition of multiline indicators\n */\nexport function dumpBlock(data, options = { lineWidth: -1 }) {\n  const parsed = jsyaml.dump(data, options);\n\n  let out = parsed;\n\n  const blockFields = Object.keys(data).filter((k) => {\n    if (typeof data[k] === 'string') {\n      return data[k].includes('\\n');\n    }\n  });\n\n  if (blockFields.length) {\n    for (const key of blockFields) {\n      const { header, indentation } = getBlockDescriptor(out, key);\n\n      const scalarStyle = options[key]?.scalarStyle ?? '|';\n      const chomping = options[key]?.chomping ?? '';\n\n      /**\n       * Replace the original block indicators with the ones provided in the options param\n       */\n      if (header) {\n        out = out.replace(header, `${ key }: ${ scalarStyle }${ chomping }${ indentation }`);\n      }\n    }\n  }\n\n  return out;\n}\n"],"mappings":"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","ignoreList":[]}]}